import{_ as t,c as s,o as a,a as n}from"./app-lCTfir8o.js";const d={},e=n(`<h1 id="应知应会的jvm相关知识" tabindex="-1"><a class="header-anchor" href="#应知应会的jvm相关知识"><span>应知应会的JVM相关知识</span></a></h1><p>&quot;一次编译、到处运行&quot; 说的是Java语言跨平台的特性， Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。 严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。</p><h2 id="_1、解释还是编译" tabindex="-1"><a class="header-anchor" href="#_1、解释还是编译"><span>1、解释还是编译</span></a></h2><p>我们经常听说一门语言是解释型还是编译型的语言，那么java呢？。</p><ul><li>解释型：代码没有编译的过程，读一行执行一行，比如我们以后要学习的javascreipt。</li><li>编译型：运行之前需要将代码先编译成【机器指令】，再运行，比如c语言。</li></ul><hr><p>我们都知道java是存在编译过程的，但是java的编译和c语言不一样，java不是编译成具体的【机器指令】，因为不同的硬件结构和操作系统有不同的机器指令，java为了实现【一次编写、随处运行】的目标，实际上编译出的指令是【字节码】，字节码只能由jvm识别，我们的硬件是无法识别的，运行的过程却是由jvm使用解释的方式执行。</p><p>但是为了提升效率，jvm推出了JIT（Just In Time Compile 即时编译器），就是在运行过程中，能将部分热点代码，直接编译成机器码，加快执行效率。甚至在java9中提出了AOT编译器（Ahead Of Time，指运行前编译）。</p><p>所以到目前为止，在 JVM 中有三个非常重要的编译器，它们分别是：前端编译器、JIT 编译器、AOT 编译器。</p><ul><li><p>前端编译器，最常见的就是我们的 javac 编译器，其将 Java 源代码编译为 Java 字节码文件。</p></li><li><p>JIT 即时编译器，最常见的是 HotSpot 虚拟机中的 Client Compiler 和 Server Compiler，其将 Java 字节码编译为本地机器代码。</p></li><li><p>AOT 编译器则能将源代码直接编译为本地机器码。</p></li><li><p>JIT：吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制。</p></li><li><p>AOT：内存占用低，启动速度快，可以无需 runtime 运行，直接将 runtime 静态链接至最终的程序中，但是无运行时性能加成，不能根据程序运行情况做进一步的优化。</p><p>而在 JVM 中，通过这几种不同方式的配合，使得 JVM 的编译质量和运行速度达到最优的状态。</p></li></ul><h2 id="_2、动态类型还是静态类型" tabindex="-1"><a class="header-anchor" href="#_2、动态类型还是静态类型"><span>2、动态类型还是静态类型</span></a></h2><ul><li>静态类型语言：变量定义时有类型声明的语言。</li></ul><p>（1）变量的类型在编译的时候确定</p><p>（2）变量的类型在运行时不能修改</p><p>这样编译器就可以确定运行时需要的内存总量。 例如：C、Scala、Java、F#语言是静态类型语言。</p><ul><li>动态类型语言：变量定义时无类型声明的语言。</li></ul><p>（1）变量的类型在运行的时候确定</p><p>（2）变量的类型在运行可以修改</p><p>例如：python、Javascript、Ruby语言是动态类型语言。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">i <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">;</span></span>
<span class="line">i <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>强类型定义语言：一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。强类型定义语言是类型安全的语言。</li><li>弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。</li></ul><p>java是一门静态的强类型语言。</p><h2 id="_3、实例对象的内存分布" tabindex="-1"><a class="header-anchor" href="#_3、实例对象的内存分布"><span>3、实例对象的内存分布</span></a></h2><p>先玩一点高级的，先探明一个类的实例对象在内存是什么样子的</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/image-20210824103408501.a88b8e38.png" alt="image-20210824103408501"></p><p><strong>1、（Mark Word）标记位</strong></p><p>这里边记录了一些描述对象的信息，目前先不用理解。</p><p><strong>2、指向类的指针</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line"> 该指针在32位JVM中的长度是32bit，在64位JVM中长度是64bit。jvm中默认开启指针压缩，就是32位。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Java对象的类数据保存在方法区，我们一定要知道，实例对象是实例对象，类是类，实例对象是根据类new出来的，而这个类保存在方法区。</p><p><strong>3、数组长度</strong></p><p>只有数组对象保存了这部分数据，该数据在32位和64位JVM中长度都是32bit。从这个角度我们也能明白一个数组最长是多长了。</p><p><strong>4、实例数据</strong> 对象的实例数据就是成员变量的值，可能是基础数据类型的值可能是引用。</p><p><strong>5、对齐填充字节</strong></p><p>因为JVM要求java的对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数，没有特别的功能。</p><p>【一个对象在new之前就能确定大小吗？】</p><p>因为对象头是确定的，具体的字段也是确定的，所以我们在new一个对象的时候，就已经知道了一个对象具体占用多大的空间。</p><p>一个对象一旦被new出来，每个成员变量所占用的空间就已经正确的分配成功了，空间一旦有了，默认值也就有了。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">long</span> objectSize <span class="token operator">=</span> <span class="token class-name">ObjectSizeCalculator</span><span class="token punctuation">.</span><span class="token function">getObjectSize</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>objectSize<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">结果<span class="token number">16</span>byte</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>计算过程：8字节（对象头）+ 指针4字节 + 实例数据 0 + 8字节对齐 4字节 = 16byte</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>bytes <span class="token operator">=</span> bytes<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> bytes<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBytes</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>bytes <span class="token operator">=</span> bytes<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> age<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ObjectSizeCalculator</span><span class="token punctuation">.</span><span class="token function">getObjectSize</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内存分配：</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/image-20210824152125280.c912aef7.png" alt="image-20210824152125280"></p><p>计算结果：</p><p>这个其实要计算两部分：</p><ul><li>对于Test 8（对象头）+4（Klass）+ 4 (bytes的引用) + 4（int值） = 20 + 对齐 = 24字节</li><li>对于byte数组 8（对象头）+4（Klass） + 4（数组长度） + 12（具体的数据）= 32字节</li></ul><p>总的Test的大小就是 24+32 = 56字节</p><h2 id="_4、类的加载" tabindex="-1"><a class="header-anchor" href="#_4、类的加载"><span>4、类的加载</span></a></h2><p>一个类，经过编译后要形成字节码文件，然后jvm需要在【第一次主动使用这个类】的时候将这个类加载到内存的方法区。</p><p>现在我们就能了解第一次主动使用了：</p><p>1、new对象是不是，包括new自己和new子类都是。</p><p>2、调用静态方法和静态属性是不是，包含main方法的也是。</p><p>3、一会会学，反射也可以触发类的加载。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/image-20210805141759239.e917bf69.png" alt="image-20210805141759239"></p><h3 id="_1-加载" tabindex="-1"><a class="header-anchor" href="#_1-加载"><span>（1）加载</span></a></h3><ol><li>通过全限定类名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ol><h3 id="_2-验证" tabindex="-1"><a class="header-anchor" href="#_2-验证"><span>（2）验证</span></a></h3><ol><li>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li><li>文件格式验证：如是否以魔数 0xCAFEBABE 开头、主、次版本号是否在当前虚拟机处理范围之内、常量合理性验证等。</li><li>此阶段保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java类型信息的要求。</li><li>元数据验证：是否存在父类，父类的继承链是否正确，抽象类是否实现了其父类或接口之中要求实现的所有方法，字段、方法是否与父类产生矛盾等。</li><li>第二阶段，保证不存在不符合 Java 语言规范的元数据信息。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。例如保证跳转指令不会跳转到方法体以外的字节码指令上。</li><li>符号引用验证：在解析阶段中发生，保证可以将符号引用转化为直接引用。</li></ol><h3 id="_3-准备" tabindex="-1"><a class="header-anchor" href="#_3-准备"><span>（3）准备</span></a></h3><ol><li>为静态变量分配内存并设置类变量初始值，这些变量所使用的内存都将在方法区中进行分配。</li></ol><h3 id="_4-解析" tabindex="-1"><a class="header-anchor" href="#_4-解析"><span>（4）解析</span></a></h3><ol><li>虚拟机将常量池内的符号引用替换为直接引用的过程。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。</li></ol><h3 id="_5-初始化" tabindex="-1"><a class="header-anchor" href="#_5-初始化"><span>（5）初始化</span></a></h3><p>到初始化阶段，才真正开始执行编译的指令阶段，此阶段是执行 <code>&lt;clinit&gt;()</code> 方法的过程。<code>&lt;clinit&gt;()</code> 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句合并产生的。（不包括构造器中的语句。构造器是初始化对象的，类加载完成后，创建对象时候将调用的 <code>&lt;init&gt;()</code> 方法来初始化对象）</p><p>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如下程序：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">static</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 给变量赋值可以正常编译通过</span></span>
<span class="line">        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 这句编译器会提示&quot;非法向前引用&quot;</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上这 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用，例如：</p><ol><li>通过子类引用父类的静态字段，不会导致子类初始化。</li><li>通过数组定义来引用类，不会触发此类的初始化。<code>MyClass[] cs = new MyClass[10];</code></li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ol><p>【总结：new一个对象过程中发生了什么？】</p><ol><li>**确认类元信息是否存在。**当 JVM 接收到 new 指令时，首先在 metaspace 内检查需要创建的类元信息是否存在。 若不存在，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名＋类名为 Key 进行查找对应的 class 文件。 如果没有找到文件，则抛出 ClassNotFoundException 异常 ， 如果找到，则进行类加载（加载 - 验证 - 准备 - 解析 - 初始化），并生成对应的 Class 类对象。</li><li><strong>分配对象内存。</strong> 首先计算对象占用空间大小，如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小，接着在堆中划分—块内存给新对象。</li><li><strong>设定默认值。</strong> 成员变量值都需要设定为默认值， 即各种不同形式的零值。</li><li>**设置对象头。**设置新对象的哈希码、 GC 信息、锁信息、对象所属的类元信息等。这个过程的具体设置方式取决于 JVM 实现。</li><li><strong>执行 init 方法。</strong> 初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</li></ol><h2 id="_5、类加载器" tabindex="-1"><a class="header-anchor" href="#_5、类加载器"><span>5、类加载器</span></a></h2><p>类加载器就是一段代码【classloader】，他能通过一个类的&#39;&#39;全限定名&#39;&#39;来获取描述此类的二进制字节流，把字节码文件加载到方法区。然后在堆内（heap）创建一个 java.lang.Class 对象，Class 对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/image-20210806150423581.181de308.png" alt="image-20210806150423581"></p><p>jvm当中有以下几个类加载器，他们负责从不同的classpath下加载字节码文件，classpath就是存放字节码文件的文件目录。</p><ul><li>【Bootstrap Classloader】启动类加载器，主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 &lt;JAVA_HOME&gt;/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。</li><li>【Extension ClassLoader】扩展类加载器由Java语言实现的，它负责加载&lt;JAVA_HOME&gt;/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</li><li>【Application ClassLoader】系统应用类加载器，它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器，就是我们写的代码。</li></ul><p>【双亲委派模型】</p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/image-20210805184616651.2d911f1f.png" alt="image-20210805184616651"></p><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line">    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// 看一看，这个类是不是已经被加载了</span></span>
<span class="line">            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token comment">// 如果没有，就开是尝试加载了</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    	<span class="token comment">// 这句话，其实就告诉你了默认是，尝试让父类去加载</span></span>
<span class="line">                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                    <span class="token punctuation">}</span></span>
<span class="line">                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    <span class="token comment">// ClassNotFoundException thrown if class not found</span></span>
<span class="line">                    <span class="token comment">// from the non-null parent class loader</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    <span class="token comment">// If still not found, then invoke findClass in order</span></span>
<span class="line">                    <span class="token comment">// to find the class.</span></span>
<span class="line">                    <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">                    <span class="token comment">// this is the defining class loader; record the stats</span></span>
<span class="line">                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">            <span class="token keyword">return</span> c<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这玩意，其实也是一个类，这个类的作用是从某个文件夹（classpath）下拉取字节码文件：</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/image-20210805185501539.c24497ff.png" alt="image-20210805185501539"></p><p>双亲委派有什么好处：</p><p>1、防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。</p><p>2、保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。</p><p>其实我们可以通过重写loadClass和findClass方法来打破双亲委派，来根据我们自身的业务特性实现相应的类加载机制。但是我们我们目前的知识储备太少，等我们学完了框架再回过头来一起分析tomcat是如何打破双亲委派模型实现多个应用程序的环境隔离。</p><h2 id="_6、运行时数据区" tabindex="-1"><a class="header-anchor" href="#_6、运行时数据区"><span>6、运行时数据区</span></a></h2><p>Java虚拟机定义了一系列逻辑数据区域，有些是随着虚拟机的启动而创建，虚拟机的关闭而销毁。还有一部分是随着线程生命周期创建销毁的。在学习之前我们需要了解一下线程的基本概念如下，大家尽量理解就可以了。</p><p>进程（Process）我们可以这样简单的理解，一个应用程序就是一个进程。</p><p>线程（thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p><p>现在咱们看看jvm的运行时内存分布：</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/image-20210806164903998.ab963a2c.png" alt="image-20210806164903998"></p><p>在Java虚拟机中堆是所有线程都可以共享的内存区域，是存放所有类实例和数组对象的地方。在虚拟机启动就根据相关堆参数，创建堆，它也是垃圾收集器工作的主要区域。</p><p>堆内存里的对象不会被显式的回收，而是由【垃圾回收器回收】，为了配合垃圾收集器的特性我们可以把堆分为年轻代和老年代。</p><h3 id="_1-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#_1-虚拟机栈"><span>（1）虚拟机栈</span></a></h3><p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame，是方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>每个栈桢又有独立的数据结构：</p><h4 id="a-局部变量表" tabindex="-1"><a class="header-anchor" href="#a-局部变量表"><span>a. 局部变量表</span></a></h4><p>局部变量表是存放方法参数和局部变量的区域。 局部变量没有准备阶段， 必须显式初始化。如果是非静态方法，<strong>则在 index[0] 位置上存储的是方法所属对象的实例引用</strong>，一个引用变量占 4 个字节，随后存储的是参数和局部变量。字节码指令中的 STORE 指令就是将操作栈中计算完成的局部变呈写回局部变量表的存储空间内。</p><p>虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</p><h4 id="b-操作数栈" tabindex="-1"><a class="header-anchor" href="#b-操作数栈"><span>b. 操作数栈</span></a></h4><blockquote><p>i++ 和 ++i 的区别：</p></blockquote><ol><li>i++：从局部变量表取出 i 并压入操作栈(load memory)，然后对局部变量表中的 i 自增 1(add&amp;store memory)，将操作栈栈顶值取出使用，如此线程从操作栈读到的是自增之前的值。</li><li>++i：先对局部变量表的 i 自增 1(load memory&amp;add&amp;store memory)，然后取出并压入操作栈(load memory)，再将操作栈栈顶值取出使用，线程从操作栈读到的是自增之后的值。</li></ol><h4 id="c-动态链接" tabindex="-1"><a class="header-anchor" href="#c-动态链接"><span>c. 动态链接</span></a></h4><p>每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。</p><h4 id="d-方法返回地址" tabindex="-1"><a class="header-anchor" href="#d-方法返回地址"><span>d.方法返回地址</span></a></h4><p>方法执行时有两种退出情况：</p><ol><li>正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN 等；</li><li>异常退出。</li></ol><p>无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：</p><ol><li>返回值压入上层调用栈帧。</li><li>异常信息抛给能够处理的栈帧。</li><li>PC计数器指向方法调用后的下一条指令。</li></ol><h2 id="_7、-本地方法栈" tabindex="-1"><a class="header-anchor" href="#_7、-本地方法栈"><span>7、 本地方法栈</span></a></h2><p>本地方法（Native Method）：一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。java语言本身无法调用很多的系统资源的，需要JVM和系统打交道，比如操作内存、处理文件、线程调度等。而这部分代码不能用java直接实现，往往是使用C++写的，这类方法就是本地方法。</p><p>其实我们见过不少：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">protected</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>他们被native修饰，没有方法体，但他们不是抽象方法，他们的实现不是java实现的，你要知道jvm本身就是C++写的。</p><p>如果我们想在Java底层里调用别的语言代码的话就需要用到别的方法栈了,比如Java虚拟机的实现会用到传统的栈(C stack)来调用native方法，这个就是本地方法栈的应用，当然这个不是必须实现的，完全取决于虚拟机的实现。</p><h2 id="_8、程序计数器" tabindex="-1"><a class="header-anchor" href="#_8、程序计数器"><span>8、程序计数器</span></a></h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p><p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><h2 id="_9、java堆" tabindex="-1"><a class="header-anchor" href="#_9、java堆"><span>9、Java堆</span></a></h2><p>对于大多数应用来说，Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p><h2 id="_10、方法区" tabindex="-1"><a class="header-anchor" href="#_10、方法区"><span>10、方法区</span></a></h2><p>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据一句话总结就是存储<strong>元数据</strong>地方</p><p>JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。</p><p>为什么要使用元空间取代永久代的实现？</p><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li></ol><h2 id="_11、垃圾回收" tabindex="-1"><a class="header-anchor" href="#_11、垃圾回收"><span>11、垃圾回收</span></a></h2><p>其实我们java程序中的绝大部分对象都是朝生夕死的。那些使用过，以后不会再使用的对象，是需要从堆内存清除掉的。当然【栈内存】是不需要清除数据的，栈这种数据结构的特点是，一个数据从栈中弹出，数据自然就被清理掉了，当然【方法区】存有我们的元数据这些数据也是不需要清理的。</p><h3 id="_1-回收算法" tabindex="-1"><a class="header-anchor" href="#_1-回收算法"><span>（1）回收算法</span></a></h3><blockquote><p>引用计数法</p></blockquote><p>给对象添加一引用计数器，被引用一次计数器值就加 1；当引用失效时，计数器值就减 1；计数器为 0 时，对象就是不可能再被使用的，简单高效，缺点是无法解决对象之间相互循环引用的问题。</p><blockquote><p>可达性分析算法(根可达算法)</p></blockquote><p>通过一系列的称为 &quot;GC Roots&quot; 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有</p><p>任何引用链相连时，则证明此对象是不可用的。此算法解决了上述循环引用的问题。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/2184951-06859aad2e07258d.b3ee8b43.png" alt="img"></p><p>在Java语言中，可作为 GC Roots 的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li></ul><h3 id="_2-垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_2-垃圾回收算法"><span>（2）垃圾回收算法</span></a></h3><blockquote><p>垃圾收集算法一共有 4 种：</p></blockquote><ol><li>标记-清除算法</li><li>复制算法</li><li>标记整理算法</li><li>分代收集算法</li></ol><h4 id="第一种-标记-清除算法" tabindex="-1"><a class="header-anchor" href="#第一种-标记-清除算法"><span>第一种：标记-清除算法</span></a></h4><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>它的主要不足有两个：</p><ol><li>效率问题，标记和清除两个过程的效率都不高；</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol><p>标记—清除算法的执行过程如下图。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/14923529-32d5034ee61de6cc.0027ef87.png" alt="img"></p><h4 id="第二种-复制算法" tabindex="-1"><a class="header-anchor" href="#第二种-复制算法"><span>第二种：复制算法</span></a></h4><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。复制算法的执行过程如下图：</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/14923529-2f1313c6b35c1f5b.1f6209d0.png" alt="img"></p><h4 id="第三种-标记-整理算法" tabindex="-1"><a class="header-anchor" href="#第三种-标记-整理算法"><span>第三种：标记-整理算法</span></a></h4><p>复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后<strong>直接清理掉端边界以外的内存</strong>，“标记-整理”算法的示意图如下：</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/14923529-76fb92c61eff10b2.b945e065.png" alt="img"></p><h4 id="第四种-分代收集算法" tabindex="-1"><a class="header-anchor" href="#第四种-分代收集算法"><span>第四种：分代收集算法</span></a></h4><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，根据对象存活周期的不同将内存划分为几块并采用不用的垃圾收集算法。他不是新的算法，只是前三种算法的融合。</p><p>一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/image-20210824120250286.35f833fd.png" alt="image-20210824120250286"></p><p>下图是new一个对象之后，这个对象的内存分配流程：</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/image-20210806161855200.60bf527d.png" alt="image-20210806161855200"></p><p><strong>1、对象优先在Eden分配</strong></p><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。当然如果有些小对象也可能直接在栈上分配。</p><p><strong>2、Minor GC 和 Full GC 有什么不一样吗？</strong></p><ul><li>新生代 GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li><li>老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。一旦出现fullGC就必然会出现STW，stop the world。</li></ul><p><strong>3、大对象直接进入老年代</strong></p><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组（ byte[] 数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（特别是短命大对象，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><p><strong>4、长期存活的对象将进入老年代</strong></p><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。这个年龄就记在对象头中。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1 。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。</p><p><strong>5、动态对象年龄判定</strong></p><p>为了能更好地适应不同程序的内存状况，无须等到 MaxTenuringThreshold 中要求的年龄，同年对象达到 Survivor 空间的一半后，他们以及年龄大于他们的对象都将直接进入老年代。</p><p><strong>6、空间分配担保</strong></p><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代，所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。</p><p>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC ，否则将进行 Full GC 。</p><h2 id="_13、垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_13、垃圾回收器"><span>13、垃圾回收器</span></a></h2><p>垃圾回收器有自己的发展过程，整个发展基本是围绕硬件的发展而展开的，比如我们最早的电脑可能只有几十k的内存，慢慢的增长到几十兆，再到现在的几个g，甚至几个T，cpu更是从单核到现在16核 32核。</p><p>垃圾清理本来就是一个打扫卫生的工作，你想想，原来是40平米的房子你妈妈一个人清理，后来的联排别墅，家里10个保姆一起清理，管理的方法肯定不同。</p><p>这玩意就是打扫卫生的，作用在堆内存。咱们先说一个场景，你家有五个孩子，把家里弄的乱糟糟，爸爸妈妈负责打扫卫生。</p><p>以下内容简单了解，看不懂了以后学习jvm：</p><h3 id="第一-serial收集器-串行收集器" tabindex="-1"><a class="header-anchor" href="#第一-serial收集器-串行收集器"><span>第一：Serial收集器（串行收集器）</span></a></h3><p>这种收集器的流程是这样的：你妈大喊，都别动，接着你妈开始打扫，直到你妈打扫完你们开始做自己的工作。</p><p>Serial 收集器是最基本、发展历史最悠久的收集器，曾经是虚拟机新生代收集的唯一选择。这是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。这个过程叫做&quot;Stop The World&quot;，这是造成程序卡顿的原因之一，只不过一般的时间比较小感知不到而已。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/14923529-9bf73c0cdf9a7066.bbdb6dc2.png" alt="img"></p><h3 id="第二-serial-old-收集器" tabindex="-1"><a class="header-anchor" href="#第二-serial-old-收集器"><span>第二：Serial Old 收集器</span></a></h3><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/14923529-7710a429f033fc31.a73b315a.png" alt="img"></p><h3 id="第三-parallel-old收集器" tabindex="-1"><a class="header-anchor" href="#第三-parallel-old收集器"><span>第三：Parallel Old收集器</span></a></h3><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/14923529-627c4ce9f8eae23c.4e02e816.png" alt="img"></p><p>下边几种，咱们以后有Jvm专题的时候讲，不好理解</p><h3 id="第四-parallel-scavenge收集器" tabindex="-1"><a class="header-anchor" href="#第四-parallel-scavenge收集器"><span>第四：Parallel Scavenge收集器</span></a></h3><p>它主要关注吞吐量，所谓吞吐量就是<strong>代码运行时间</strong>/（<strong>代码运行时间</strong>+<strong>垃圾回收时间</strong>）。比如虚拟机运行100分钟，垃圾回收耗时1分钟，那么吞吐量就是99%。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/d439b6003af33a87c2dc66521f0c163f5243b598.ea4a907f.jpeg" alt="img"></p><h3 id="第五-parnew收集器" tabindex="-1"><a class="header-anchor" href="#第五-parnew收集器"><span>第五：ParNew收集器</span></a></h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。ParNew 收集器的工作过程如下图所示。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/14923529-bdc22bf25c2c8ba7.2985378a.png" alt="img"></p><h3 id="第六-cms收集器" tabindex="-1"><a class="header-anchor" href="#第六-cms收集器"><span>第六：CMS收集器</span></a></h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/14923529-6401f1a80d3f1c81.1379facf.png" alt="img"></p><p>CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿。</p><h3 id="第七-g1收集器" tabindex="-1"><a class="header-anchor" href="#第七-g1收集器"><span>第七：G1收集器</span></a></h3><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，JDK1.9已经默认使用这个垃圾回收器了。G1 是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点。</p><p>G1依然属于分代垃圾回收器，它会区分年代和老年代，依然有eden和survivor区，但从堆的结构上看，它并不要求整个eden区、年清代或者老年代都连续。它使用了全新的分区算法。其特点如下：</p><p>并行性：G1在回收期间，可以由多个GC线程同时工作，有效利用多核计算能力。</p><p>并发性：G1拥有与应用程序交替执行的能力，因此一般来说，不会在整个回收期间完全阻塞应用程序。</p><p>分代GC：与之前回收器不同，其他回收器，它们要么工作在年轻代要么工作在老年代。G1可以同时兼顾年轻代与老年代。</p><p>空间整理：G1在回收过程中，会进行适当的对象移动，不像CMS，只是简单的标记清除，在若干次GC后CMS必须进行一次碎片整理，G1在每次回收时都会有效的复制对象，减少空间碎片。</p><p>可预见性：由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收范围，因此对于全局停顿也能得到更好的控制。</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/14923529-8cdd3afd7d545435.8669b8ad.png" alt="img"></p><p>上述的垃圾收集器并非是可以随意搭配的，有搭配要求，详细搭配如下：</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/image-20210806173629893.3f9d58df.png" alt="image-20210806173629893"></p><p><strong>第一种：新生代使用Serial，老年代使用Serial Old</strong></p><p>最古老的，单线程，独占式，成熟，适合单CPU 服务器，如果你的服务器是单核CPU，就这个想都不用想,速度一定是最快的。</p><p><strong>第二种：新生代使用ParallelScanvenge，老年代使用Parallel Old</strong></p><p>相比第三种，对于吞吐量的关注延伸至老年代，并且老年代也采用多线程回收，是对面向吞吐量特性开发的组合，如果关注吞吐量推荐使用第四种</p><p><strong>第三种：表示新生代使用ParNew，老年代的用CMS</strong></p><p>这一套的使用，更加关注一个项目的吞吐量。</p><p><strong>第四种：使用G1</strong>，G1之后慢慢的从分代垃圾回收向分区垃圾回收转变</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/image-20210824175042147.e4091a89.png" alt="image-20210824175042147"></p><h2 id="_14、常用jvm参数" tabindex="-1"><a class="header-anchor" href="#_14、常用jvm参数"><span>14、常用JVM参数</span></a></h2><p>网上有很详细的关于各种JVM参数说明，本篇只记录很常用的几个参数，为了方便以后自己查阅</p><h3 id="_1、jvm三种参数类型" tabindex="-1"><a class="header-anchor" href="#_1、jvm三种参数类型"><span><strong>1、JVM三种参数类型</strong></span></a></h3><ul><li>标准参数。如 -version、-help</li><li>非标准参数。如 -Xms、-Xmx</li><li>不稳定参数。如-XX:+PrintGC</li></ul><h3 id="_2、xx参数数值类型" tabindex="-1"><a class="header-anchor" href="#_2、xx参数数值类型"><span><strong>2、XX参数数值类型</strong></span></a></h3><ul><li>布尔类型。如-XX:+PrintGCDetails，其中 + 和 - 分别表示开启/关闭某个属性，PrintGCDetails表示打印GC详情</li><li>KV设值类型。如-XX:NewSize=256M，设置年轻代空间大小为256M</li></ul><h3 id="_3、常用参数" tabindex="-1"><a class="header-anchor" href="#_3、常用参数"><span><strong>3、常用参数</strong></span></a></h3><p>X参数：</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/647585-20200612174516774-1900931464.c47ca4b1.png" alt="img"></p><p>XX参数：</p><ul><li>-XX:NewSize：设置年轻代最小空间大小</li><li>-XX:MaxNewSize：设置年轻代最大空间大小</li><li>-XX:PermSize：设置永久代最小空间大小</li><li>-XX:MaxPermSize：设置永久代最大空间大小</li><li>-XX:NewRatio：设置年轻代和老年代的比值。默认值-XX:NewRatio=2，表示年轻代与老年代比值为1:2，年轻代占整个堆大小的1/3</li><li>-XX:SurvivorRatio：设置年轻代中Eden区Survivor区的容量比值。默认值-XX:SurvivorRatio=8，表示Eden : Survivor0 : Survivor1 = 8 : 1 : 1</li></ul><p><strong>4、GC日志</strong></p><p>在设置JVM参数的时候，可以设置GC打印日志参数：-XX:+PrintGCDetails。下面GC输出日志信息：</p><p><img src="https://www.ydlclass.com/doc21xnv/assets/647585-20200612181734029-959765279.55393790.png" alt="img"></p><p>日志含义如下：</p><p>GC：表示进行了一次Minor GC，即从年轻代空间(包括 Eden 和 Survivor 区域)回收内存</p><p>Allocation Failure：在年轻代中没有足够的空间能够存储新的数据</p><p>Full GC (Ergonomics)：表示进行了一次Full GC，即清理整个堆空间(包含年轻代和老年代)</p><p>PSYoungGen: 1024K-&gt;1024K(1536K)：垃圾回收器是Paralle Scavenge，年轻代区GC前-&gt;GC后该区域已使用量，后面的1536表示该区域总量</p><p>ParOldGen: 4032K-&gt;4032K(4096K)：老年代区，GC前-&gt;GC后该区域已使用量，后面的4096表示该区域总量</p><p>5056K-&gt;5056K(5632K)：GC前 -&gt; GC后Java堆的使用量，后面的5632表示Java堆总量</p><p>Metaspace: 3117K-&gt;3117K(1056768K)：JDK8中取消了永久代，新增了一个叫元空间(Metaspace)的区域，对应的还是JVM规范中的方法区(主要存放一些class和元数据的信息)，该数据表示该区GC前后使用量</p><p>0.0214352 secs：暂停STW 时间，即GC的时间</p><p>Times: user=0.02 sys=0.01, real=0.02 secs：更为详细的时间占比统计</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">[GC (Allocation Failure) [PSYoungGen: 4704K-&gt;488K(6144K)] 4704K-&gt;700K(19968K), 0.0005987 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span>
<span class="line">Heap</span>
<span class="line"> PSYoungGen      total 6144K, used 2871K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000)</span>
<span class="line">  eden space 5632K, 42% used [0x00000000ff980000,0x00000000ffbd3e18,0x00000000fff00000)</span>
<span class="line">  from space 512K, 95% used [0x00000000fff00000,0x00000000fff7a020,0x00000000fff80000)</span>
<span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span>
<span class="line"> ParOldGen       total 13824K, used 212K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000)</span>
<span class="line">  object space 13824K, 1% used [0x00000000fec00000,0x00000000fec35020,0x00000000ff980000)</span>
<span class="line"> Metaspace       used 3142K, capacity 4496K, committed 4864K, reserved 1056768K</span>
<span class="line">  class space    used 343K, capacity 388K, committed 512K, reserved 1048576K</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="附录-jvm指令" tabindex="-1"><a class="header-anchor" href="#附录-jvm指令"><span>附录：jvm指令</span></a></h2><table><thead><tr><th>指令码</th><th>助记符</th><th>说明</th></tr></thead><tbody><tr><td>0x00</td><td>nop</td><td>什么都不做</td></tr><tr><td>0x01</td><td>aconst_null</td><td>将 null 推送至栈顶</td></tr><tr><td>0x02</td><td>iconst_m1</td><td>将 int 型 -1 推送至栈顶</td></tr><tr><td>0x03</td><td>iconst_0</td><td>将 int 型 0 推送至栈顶</td></tr><tr><td>0x04</td><td>iconst_1</td><td>将 int 型 1 推送至栈顶</td></tr><tr><td>0x05</td><td>iconst_2</td><td>将 int 型 2 推送至栈顶</td></tr><tr><td>0x06</td><td>iconst_3</td><td>将 int 型 3 推送至栈顶</td></tr><tr><td>0x07</td><td>iconst_4</td><td>将 int 型 4 推送至栈顶</td></tr><tr><td>0x08</td><td>iconst_5</td><td>将 int 型 5 推送至栈顶</td></tr><tr><td>0x09</td><td>lconst_0</td><td>将 long 型 0 推送至栈顶</td></tr><tr><td>0x0a</td><td>lconst_1</td><td>将 long 型 1 推送至栈顶</td></tr><tr><td>0x0b</td><td>fconst_0</td><td>将 float 型 0 推送至栈顶</td></tr><tr><td>0x0c</td><td>fconst_1</td><td>将 float 型 1 推送至栈顶</td></tr><tr><td>0x0d</td><td>fconst_2</td><td>将 float 型 2 推送至栈顶</td></tr><tr><td>0x0e</td><td>dconst_0</td><td>将 double 型 0 推送至栈顶</td></tr><tr><td>0x0f</td><td>dconst_1</td><td>将 double 型 1 推送至栈顶</td></tr><tr><td>0x10</td><td>bipush</td><td>将单字节的常量值 (-128~127) 推送至栈顶</td></tr><tr><td>0x11</td><td>sipush</td><td>将一个短整型常量值 (-32768~32767) 推送至栈顶</td></tr><tr><td>0x12</td><td>ldc</td><td>把常量池中的项压入栈</td></tr><tr><td>0x13</td><td>ldc_w</td><td>把常量池中的项压入栈（使用宽索引）</td></tr><tr><td>0x14</td><td>ldc2_w</td><td>将 long 或 double 型常量值从常量池中推送至栈顶（宽索引）</td></tr><tr><td>0x15</td><td>iload</td><td>将指定的 int 型本地变量推送至栈顶</td></tr><tr><td>0x16</td><td>lload</td><td>将指定的 long 型本地变量推送至栈顶</td></tr><tr><td>0x17</td><td>fload</td><td>将指定的 float 型本地变量推送至栈顶</td></tr><tr><td>0x18</td><td>dload</td><td>将指定的 double 型本地变量推送至栈顶</td></tr><tr><td>0x19</td><td>aload</td><td>将指定的引用类型本地变量推送至栈顶</td></tr><tr><td>0x1a</td><td>iload_0</td><td>将第一个 int 型本地变量推送至栈顶</td></tr><tr><td>0x1b</td><td>iload_1</td><td>将第二个 int 型本地变量推送至栈顶</td></tr><tr><td>0x1c</td><td>iload_2</td><td>将第三个 int 型本地变量推送至栈顶</td></tr><tr><td>0x1d</td><td>iload_3</td><td>将第四个 int 型本地变量推送至栈顶</td></tr><tr><td>0x1e</td><td>lload_0</td><td>将第一个 long 型本地变量推送至栈顶</td></tr><tr><td>0x1f</td><td>lload_1</td><td>将第二个 long 型本地变量推送至栈顶</td></tr><tr><td>0x20</td><td>lload_2</td><td>将第三个 long 型本地变量推送至栈顶</td></tr><tr><td>0x21</td><td>lload_3</td><td>将第四个 long 型本地变量推送至栈顶</td></tr><tr><td>0x22</td><td>fload_0</td><td>将第一个 float 型本地变量推送至栈顶</td></tr><tr><td>0x23</td><td>fload_1</td><td>将第二个 float 型本地变量推送至栈顶</td></tr><tr><td>0x24</td><td>fload_2</td><td>将第三个 float 型本地变量推送至栈顶</td></tr><tr><td>0x25</td><td>fload_3</td><td>将第四个 float 型本地变量推送至栈顶</td></tr><tr><td>0x26</td><td>dload_0</td><td>将第一个 double 型本地变量推送至栈顶</td></tr><tr><td>0x27</td><td>dload_1</td><td>将第二个 double 型本地变量推送至栈顶</td></tr><tr><td>0x28</td><td>dload_2</td><td>将第三个 double 型本地变量推送至栈顶</td></tr><tr><td>0x29</td><td>dload_3</td><td>将第四个 double 型本地变量推送至栈顶</td></tr><tr><td>0x2a</td><td>aload_0</td><td>将第一个引用类型本地变量推送至栈顶</td></tr><tr><td>0x2b</td><td>aload_1</td><td>将第二个引用类型本地变量推送至栈顶</td></tr><tr><td>0x2c</td><td>aload_2</td><td>将第三个引用类型本地变量推送至栈顶</td></tr><tr><td>0x2d</td><td>aload_3</td><td>将第四个引用类型本地变量推送至栈顶</td></tr><tr><td>0x2e</td><td>iaload</td><td>将 int 型数组指定索引的值推送至栈顶</td></tr><tr><td>0x2f</td><td>laload</td><td>将 long 型数组指定索引的值推送至栈顶</td></tr><tr><td>0x30</td><td>faload</td><td>将 float 型数组指定索引的值推送至栈顶</td></tr><tr><td>0x31</td><td>daload</td><td>将 double 型数组指定索引的值推送至栈顶</td></tr><tr><td>0x32</td><td>aaload</td><td>将引用型数组指定索引的值推送至栈顶</td></tr><tr><td>0x33</td><td>baload</td><td>将 boolean 或 byte 型数组指定索引的值推送至栈顶</td></tr><tr><td>0x34</td><td>caload</td><td>将 char 型数组指定索引的值推送至栈顶</td></tr><tr><td>0x35</td><td>saload</td><td>将 short 型数组指定索引的值推送至栈顶</td></tr><tr><td>0x36</td><td>istore</td><td>将栈顶 int 型数值存入指定本地变量</td></tr><tr><td>0x37</td><td>lstore</td><td>将栈顶 long 型数值存入指定本地变量</td></tr><tr><td>0x38</td><td>fstore</td><td>将栈顶 float 型数值存入指定本地变量</td></tr><tr><td>0x39</td><td>dstore</td><td>将栈顶 double 型数值存入指定本地变量</td></tr><tr><td>0x3a</td><td>astore</td><td>将栈顶引用型数值存入指定本地变量</td></tr><tr><td>0x3b</td><td>istore_0</td><td>将栈顶 int 型数值存入第一个本地变量</td></tr><tr><td>0x3c</td><td>istore_1</td><td>将栈顶 int 型数值存入第二个本地变量</td></tr><tr><td>0x3d</td><td>istore_2</td><td>将栈顶 int 型数值存入第三个本地变量</td></tr><tr><td>0x3e</td><td>istore_3</td><td>将栈顶 int 型数值存入第四个本地变量</td></tr><tr><td>0x3f</td><td>lstore_0</td><td>将栈顶 long 型数值存入第一个本地变量</td></tr><tr><td>0x40</td><td>lstore_1</td><td>将栈顶 long 型数值存入第二个本地变量</td></tr><tr><td>0x41</td><td>lstore_2</td><td>将栈顶 long 型数值存入第三个本地变量</td></tr><tr><td>0x42</td><td>lstore_3</td><td>将栈顶 long 型数值存入第四个本地变量</td></tr><tr><td>0x43</td><td>fstore_0</td><td>将栈顶 float 型数值存入第一个本地变量</td></tr><tr><td>0x44</td><td>fstore_1</td><td>将栈顶 float 型数值存入第二个本地变量</td></tr><tr><td>0x45</td><td>fstore_2</td><td>将栈顶 float 型数值存入第三个本地变量</td></tr><tr><td>0x46</td><td>fstore_3</td><td>将栈顶 float 型数值存入第四个本地变量</td></tr><tr><td>0x47</td><td>dstore_0</td><td>将栈顶 double 型数值存入第一个本地变量</td></tr><tr><td>0x48</td><td>dstore_1</td><td>将栈顶 double 型数值存入第二个本地变量</td></tr><tr><td>0x49</td><td>dstore_2</td><td>将栈顶 double 型数值存入第三个本地变量</td></tr><tr><td>0x4a</td><td>dstore_3</td><td>将栈顶 double 型数值存入第四个本地变量</td></tr><tr><td>0x4b</td><td>astore_0</td><td>将栈顶引用型数值存入第一个本地变量</td></tr><tr><td>0x4c</td><td>astore_1</td><td>将栈顶引用型数值存入第二个本地变量</td></tr><tr><td>0x4d</td><td>astore_2</td><td>将栈顶引用型数值存入第三个本地变量</td></tr><tr><td>0x4e</td><td>astore_3</td><td>将栈顶引用型数值存入第四个本地变量</td></tr><tr><td>0x4f</td><td>iastore</td><td>将栈顶 int 型数值存入指定数组的指定索引位置</td></tr><tr><td>0x50</td><td>lastore</td><td>将栈顶 long 型数值存入指定数组的指定索引位置</td></tr><tr><td>0x51</td><td>fastore</td><td>将栈顶 float 型数值存入指定数组的指定索引位置</td></tr><tr><td>0x52</td><td>dastore</td><td>将栈顶 double 型数值存入指定数组的指定索引位置</td></tr><tr><td>0x53</td><td>aastore</td><td>将栈顶引用型数值存入指定数组的指定索引位置</td></tr><tr><td>0x54</td><td>bastore</td><td>将栈顶 boolean 或 byte 型数值存入指定数组的指定索引位置</td></tr><tr><td>0x55</td><td>castore</td><td>将栈顶 char 型数值存入指定数组的指定索引位置</td></tr><tr><td>0x56</td><td>sastore</td><td>将栈顶 short 型数值存入指定数组的指定索引位置</td></tr><tr><td>0x57</td><td>pop</td><td>将栈顶数值弹出</td></tr><tr><td>0x58</td><td>pop2</td><td>将栈顶的一个（long 或 double 类型的)或两个数值弹出（其它）</td></tr><tr><td>0x59</td><td>dup</td><td>复制栈顶数值并将复制值压入栈顶</td></tr><tr><td>0x5a</td><td>dup_x1</td><td>复制栈顶数值并将两个复制值压入栈顶</td></tr><tr><td>0x5b</td><td>dup_x2</td><td>复制栈顶数值并将三个（或两个）复制值压入栈顶</td></tr><tr><td>0x5c</td><td>dup2</td><td>复制栈顶一个（long 或 double 类型的)或两个（其它）数值并将复制值压入栈顶</td></tr><tr><td>0x5d</td><td>dup2_x1</td><td>&lt;待补充&gt;</td></tr><tr><td>0x5e</td><td>dup2_x2</td><td>&lt;待补充&gt;</td></tr><tr><td>0x5f</td><td>swap</td><td>将栈最顶端的两个数值互换(数值不能是 long 或 double 类型的)</td></tr><tr><td>0x60</td><td>iadd</td><td>将栈顶两 int 型数值相加并将结果压入栈顶</td></tr><tr><td>0x61</td><td>ladd</td><td>将栈顶两 long 型数值相加并将结果压入栈顶</td></tr><tr><td>0x62</td><td>fadd</td><td>将栈顶两 float 型数值相加并将结果压入栈顶</td></tr><tr><td>0x63</td><td>dadd</td><td>将栈顶两 double 型数值相加并将结果压入栈顶</td></tr><tr><td>0x64</td><td>isub</td><td>将栈顶两 int 型数值相减并将结果压入栈顶</td></tr><tr><td>0x65</td><td>lsub</td><td>将栈顶两 long 型数值相减并将结果压入栈顶</td></tr><tr><td>0x66</td><td>fsub</td><td>将栈顶两 float 型数值相减并将结果压入栈顶</td></tr><tr><td>0x67</td><td>dsub</td><td>将栈顶两 double 型数值相减并将结果压入栈顶</td></tr><tr><td>0x68</td><td>imul</td><td>将栈顶两 int 型数值相乘并将结果压入栈顶</td></tr><tr><td>0x69</td><td>lmul</td><td>将栈顶两 long 型数值相乘并将结果压入栈顶</td></tr><tr><td>0x6a</td><td>fmul</td><td>将栈顶两 float 型数值相乘并将结果压入栈顶</td></tr><tr><td>0x6b</td><td>dmul</td><td>将栈顶两 double 型数值相乘并将结果压入栈顶</td></tr><tr><td>0x6c</td><td>idiv</td><td>将栈顶两 int 型数值相除并将结果压入栈顶</td></tr><tr><td>0x6d</td><td>ldiv</td><td>将栈顶两 long 型数值相除并将结果压入栈顶</td></tr><tr><td>0x6e</td><td>fdiv</td><td>将栈顶两 float 型数值相除并将结果压入栈顶</td></tr><tr><td>0x6f</td><td>ddiv</td><td>将栈顶两 double 型数值相除并将结果压入栈顶</td></tr><tr><td>0x70</td><td>irem</td><td>将栈顶两 int 型数值作取模运算并将结果压入栈顶</td></tr><tr><td>0x71</td><td>lrem</td><td>将栈顶两 long 型数值作取模运算并将结果压入栈顶</td></tr><tr><td>0x72</td><td>frem</td><td>将栈顶两 float 型数值作取模运算并将结果压入栈顶</td></tr><tr><td>0x73</td><td>drem</td><td>将栈顶两 double 型数值作取模运算并将结果压入栈顶</td></tr><tr><td>0x74</td><td>ineg</td><td>将栈顶 int 型数值取负并将结果压入栈顶</td></tr><tr><td>0x75</td><td>lneg</td><td>将栈顶 long 型数值取负并将结果压入栈顶</td></tr><tr><td>0x76</td><td>fneg</td><td>将栈顶 float 型数值取负并将结果压入栈顶</td></tr><tr><td>0x77</td><td>dneg</td><td>将栈顶 double 型数值取负并将结果压入栈顶</td></tr><tr><td>0x78</td><td>ishl</td><td>将 int 型数值左移位指定位数并将结果压入栈顶</td></tr><tr><td>0x79</td><td>lshl</td><td>将 long 型数值左移位指定位数并将结果压入栈顶</td></tr><tr><td>0x7a</td><td>ishr</td><td>将 int 型数值右（符号）移位指定位数并将结果压入栈顶</td></tr><tr><td>0x7b</td><td>lshr</td><td>将 long 型数值右（符号）移位指定位数并将结果压入栈顶</td></tr><tr><td>0x7c</td><td>iushr</td><td>将 int 型数值右（无符号）移位指定位数并将结果压入栈顶</td></tr><tr><td>0x7d</td><td>lushr</td><td>将 long 型数值右（无符号）移位指定位数并将结果压入栈顶</td></tr><tr><td>0x7e</td><td>iand</td><td>将栈顶两 int 型数值作“按位与”并将结果压入栈顶</td></tr><tr><td>0x7f</td><td>land</td><td>将栈顶两 long 型数值作“按位与”并将结果压入栈顶</td></tr><tr><td>0x80</td><td>ior</td><td>将栈顶两 int 型数值作“按位或”并将结果压入栈顶</td></tr><tr><td>0x81</td><td>lor</td><td>将栈顶两 long 型数值作“按位或”并将结果压入栈顶</td></tr><tr><td>0x82</td><td>ixor</td><td>将栈顶两 int 型数值作“按位异或”并将结果压入栈顶</td></tr><tr><td>0x83</td><td>lxor</td><td>将栈顶两 long 型数值作“按位异或”并将结果压入栈顶</td></tr><tr><td>0x84</td><td>iinc</td><td>将指定 int 型变量增加指定值（i++,</td></tr><tr><td>0x85</td><td>i2l</td><td>将栈顶 int 型数值强制转换成 long 型数值并将结果压入栈顶</td></tr><tr><td>0x86</td><td>i2f</td><td>将栈顶 int 型数值强制转换成 float 型数值并将结果压入栈顶</td></tr><tr><td>0x87</td><td>i2d</td><td>将栈顶 int 型数值强制转换成 double 型数值并将结果压入栈顶</td></tr><tr><td>0x88</td><td>l2i</td><td>将栈顶 long 型数值强制转换成 int 型数值并将结果压入栈顶</td></tr><tr><td>0x89</td><td>l2f</td><td>将栈顶 long 型数值强制转换成 float 型数值并将结果压入栈顶</td></tr><tr><td>0x8a</td><td>l2d</td><td>将栈顶 long 型数值强制转换成 double 型数值并将结果压入栈顶</td></tr><tr><td>0x8b</td><td>f2i</td><td>将栈顶 float 型数值强制转换成 int 型数值并将结果压入栈顶</td></tr><tr><td>0x8c</td><td>f2l</td><td>将栈顶 float 型数值强制转换成 long 型数值并将结果压入栈顶</td></tr><tr><td>0x8d</td><td>f2d</td><td>将栈顶 float 型数值强制转换成 double 型数值并将结果压入栈顶</td></tr><tr><td>0x8e</td><td>d2i</td><td>将栈顶 double 型数值强制转换成 int 型数值并将结果压入栈顶</td></tr><tr><td>0x8f</td><td>d2l</td><td>将栈顶 double 型数值强制转换成 long 型数值并将结果压入栈顶</td></tr><tr><td>0x90</td><td>d2f</td><td>将栈顶 double 型数值强制转换成 float 型数值并将结果压入栈顶</td></tr><tr><td>0x91</td><td>i2b</td><td>将栈顶 int 型数值强制转换成 byte 型数值并将结果压入栈顶</td></tr><tr><td>0x92</td><td>i2c</td><td>将栈顶 int 型数值强制转换成 char 型数值并将结果压入栈顶</td></tr><tr><td>0x93</td><td>i2s</td><td>将栈顶 int 型数值强制转换成 short 型数值并将结果压入栈顶</td></tr><tr><td>0x94</td><td>lcmp</td><td>比较栈顶两 long 型数值大小，并将结果（1，0，-1）压入栈顶</td></tr><tr><td>0x95</td><td>fcmpl</td><td>比较栈顶两 float 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为 NaN 时，将 -1 压入栈顶</td></tr><tr><td>0x96</td><td>fcmpg</td><td>比较栈顶两 float 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为 NaN 时，将 1 压入栈顶</td></tr><tr><td>0x97</td><td>dcmpl</td><td>比较栈顶两 double 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为 NaN 时，将 -1 压入栈顶</td></tr><tr><td>0x98</td><td>dcmpg</td><td>比较栈顶两 double 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为 NaN 时，将 1 压入栈顶</td></tr><tr><td>0x99</td><td>ifeq</td><td>当栈顶 int 型数值等于 0 时跳转</td></tr><tr><td>0x9a</td><td>ifne</td><td>当栈顶 int 型数值不等于 0 时跳转</td></tr><tr><td>0x9b</td><td>iflt</td><td>当栈顶 int 型数值小于 0 时跳转</td></tr><tr><td>0x9c</td><td>ifge</td><td>当栈顶 int 型数值大于等于 0 时跳转</td></tr><tr><td>0x9d</td><td>ifgt</td><td>当栈顶 int 型数值大于 0 时跳转</td></tr><tr><td>0x9e</td><td>ifle</td><td>当栈顶 int 型数值小于等于 0 时跳转</td></tr><tr><td>0x9f</td><td>if_icmpeq</td><td>比较栈顶两 int 型数值大小，当结果等于 0 时跳转</td></tr><tr><td>0xa0</td><td>if_icmpne</td><td>比较栈顶两 int 型数值大小，当结果不等于 0 时跳转</td></tr><tr><td>0xa1</td><td>if_icmplt</td><td>比较栈顶两 int 型数值大小，当结果小于 0 时跳转</td></tr><tr><td>0xa2</td><td>if_icmpge</td><td>比较栈顶两 int 型数值大小，当结果大于等于 0 时跳转</td></tr><tr><td>0xa3</td><td>if_icmpgt</td><td>比较栈顶两 int 型数值大小，当结果大于 0 时跳转</td></tr><tr><td>0xa4</td><td>if_icmple</td><td>比较栈顶两 int 型数值大小，当结果小于等于 0 时跳转</td></tr><tr><td>0xa5</td><td>if_acmpeq</td><td>比较栈顶两引用型数值，当结果相等时跳转</td></tr><tr><td>0xa6</td><td>if_acmpne</td><td>比较栈顶两引用型数值，当结果不相等时跳转</td></tr><tr><td>0xa7</td><td>goto</td><td>无条件跳转</td></tr><tr><td>0xa8</td><td>jsr</td><td>跳转至指定 16 位 offset 位置，并将 jsr 下一条指令地址压入栈顶</td></tr><tr><td>0xa9</td><td>ret</td><td>返回至本地变量指定的 index 的指令位置（一般与 jsr, jsr_w 联合使用）</td></tr><tr><td>0xaa</td><td>tableswitch</td><td>用于 switch 条件跳转，case 值连续（可变长度指令）</td></tr><tr><td>0xab</td><td>lookupswitch</td><td>用于 switch 条件跳转，case 值不连续（可变长度指令）</td></tr><tr><td>0xac</td><td>ireturn</td><td>从当前方法返回 int</td></tr><tr><td>0xad</td><td>lreturn</td><td>从当前方法返回 long</td></tr><tr><td>0xae</td><td>freturn</td><td>从当前方法返回 float</td></tr><tr><td>0xaf</td><td>dreturn</td><td>从当前方法返回 double</td></tr><tr><td>0xb0</td><td>areturn</td><td>从当前方法返回对象引用</td></tr><tr><td>0xb1</td><td>return</td><td>从当前方法返回void</td></tr><tr><td>0xb2</td><td>getstatic</td><td>获取指定类的静态域，并将其值压入栈顶</td></tr><tr><td>0xb3</td><td>putstatic</td><td>为指定的类的静态域赋值</td></tr><tr><td>0xb4</td><td>getfield</td><td>获取指定类的实例域，并将其值压入栈顶</td></tr><tr><td>0xb5</td><td>putfield</td><td>为指定的类的实例域赋值</td></tr><tr><td>0xb6</td><td>invokevirtual</td><td>调用实例方法</td></tr><tr><td>0xb7</td><td>invokespecial</td><td>调用超类构造方法，实例初始化方法，私有方法</td></tr><tr><td>0xb8</td><td>invokestatic</td><td>调用静态方法</td></tr><tr><td>0xb9</td><td>invokeinterface</td><td>调用接口方法</td></tr><tr><td>0xba</td><td>–</td><td></td></tr><tr><td>0xbb</td><td>new</td><td>创建一个对象，并将其引用值压入栈顶</td></tr><tr><td>0xbc</td><td>newarray</td><td>创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压入栈顶</td></tr><tr><td>0xbd</td><td>anewarray</td><td>创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶</td></tr><tr><td>0xbe</td><td>arraylength</td><td>获得数组的长度值并压入栈顶</td></tr><tr><td>0xbf</td><td>athrow</td><td>将栈顶的异常抛出</td></tr><tr><td>0xc0</td><td>checkcast</td><td>检验类型转换，检验未通过将抛出 ClassCastException</td></tr><tr><td>0xc1</td><td>instanceof</td><td>检验对象是否是指定的类的实例，如果是将 1 压入栈顶，否则将0压入栈顶</td></tr><tr><td>0xc2</td><td>monitorenter</td><td>获得对象的锁，用于同步方法或同步块</td></tr><tr><td>0xc3</td><td>monitorexit</td><td>释放对象的锁，用于同步方法或同步块</td></tr><tr><td>0xc4</td><td>wide</td><td>&lt;待补充&gt;</td></tr><tr><td>0xc5</td><td>multianewarray</td><td>创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必须包含各维度的长度值），并将其引用值压入栈顶</td></tr><tr><td>0xc6</td><td>ifnull</td><td>为 null 时跳转</td></tr><tr><td>0xc7</td><td>ifnonnull</td><td>不为 null 时跳转</td></tr><tr><td>0xc8</td><td>goto_w</td><td>无条件跳转（宽索引）</td></tr><tr><td>0xc9</td><td>jsr_w</td><td>跳转至指定 32 位 offset 位置，并将 jsr_w 下一条指令地址压入栈顶</td></tr></tbody></table>`,246),l=[e];function p(i,o){return a(),s("div",null,l)}const r=t(d,[["render",p],["__file","JVM.html.vue"]]),u=JSON.parse('{"path":"/JavaSE1/jvm.html","title":"应知应会的JVM相关知识","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"1、解释还是编译","slug":"_1、解释还是编译","link":"#_1、解释还是编译","children":[]},{"level":2,"title":"2、动态类型还是静态类型","slug":"_2、动态类型还是静态类型","link":"#_2、动态类型还是静态类型","children":[]},{"level":2,"title":"3、实例对象的内存分布","slug":"_3、实例对象的内存分布","link":"#_3、实例对象的内存分布","children":[]},{"level":2,"title":"4、类的加载","slug":"_4、类的加载","link":"#_4、类的加载","children":[{"level":3,"title":"（1）加载","slug":"_1-加载","link":"#_1-加载","children":[]},{"level":3,"title":"（2）验证","slug":"_2-验证","link":"#_2-验证","children":[]},{"level":3,"title":"（3）准备","slug":"_3-准备","link":"#_3-准备","children":[]},{"level":3,"title":"（4）解析","slug":"_4-解析","link":"#_4-解析","children":[]},{"level":3,"title":"（5）初始化","slug":"_5-初始化","link":"#_5-初始化","children":[]}]},{"level":2,"title":"5、类加载器","slug":"_5、类加载器","link":"#_5、类加载器","children":[]},{"level":2,"title":"6、运行时数据区","slug":"_6、运行时数据区","link":"#_6、运行时数据区","children":[{"level":3,"title":"（1）虚拟机栈","slug":"_1-虚拟机栈","link":"#_1-虚拟机栈","children":[]}]},{"level":2,"title":"7、 本地方法栈","slug":"_7、-本地方法栈","link":"#_7、-本地方法栈","children":[]},{"level":2,"title":"8、程序计数器","slug":"_8、程序计数器","link":"#_8、程序计数器","children":[]},{"level":2,"title":"9、Java堆","slug":"_9、java堆","link":"#_9、java堆","children":[]},{"level":2,"title":"10、方法区","slug":"_10、方法区","link":"#_10、方法区","children":[]},{"level":2,"title":"11、垃圾回收","slug":"_11、垃圾回收","link":"#_11、垃圾回收","children":[{"level":3,"title":"（1）回收算法","slug":"_1-回收算法","link":"#_1-回收算法","children":[]},{"level":3,"title":"（2）垃圾回收算法","slug":"_2-垃圾回收算法","link":"#_2-垃圾回收算法","children":[]}]},{"level":2,"title":"13、垃圾回收器","slug":"_13、垃圾回收器","link":"#_13、垃圾回收器","children":[{"level":3,"title":"第一：Serial收集器（串行收集器）","slug":"第一-serial收集器-串行收集器","link":"#第一-serial收集器-串行收集器","children":[]},{"level":3,"title":"第二：Serial Old 收集器","slug":"第二-serial-old-收集器","link":"#第二-serial-old-收集器","children":[]},{"level":3,"title":"第三：Parallel Old收集器","slug":"第三-parallel-old收集器","link":"#第三-parallel-old收集器","children":[]},{"level":3,"title":"第四：Parallel Scavenge收集器","slug":"第四-parallel-scavenge收集器","link":"#第四-parallel-scavenge收集器","children":[]},{"level":3,"title":"第五：ParNew收集器","slug":"第五-parnew收集器","link":"#第五-parnew收集器","children":[]},{"level":3,"title":"第六：CMS收集器","slug":"第六-cms收集器","link":"#第六-cms收集器","children":[]},{"level":3,"title":"第七：G1收集器","slug":"第七-g1收集器","link":"#第七-g1收集器","children":[]}]},{"level":2,"title":"14、常用JVM参数","slug":"_14、常用jvm参数","link":"#_14、常用jvm参数","children":[{"level":3,"title":"1、JVM三种参数类型","slug":"_1、jvm三种参数类型","link":"#_1、jvm三种参数类型","children":[]},{"level":3,"title":"2、XX参数数值类型","slug":"_2、xx参数数值类型","link":"#_2、xx参数数值类型","children":[]},{"level":3,"title":"3、常用参数","slug":"_3、常用参数","link":"#_3、常用参数","children":[]}]},{"level":2,"title":"附录：jvm指令","slug":"附录-jvm指令","link":"#附录-jvm指令","children":[]}],"git":{"updatedTime":1723726527000,"contributors":[{"name":"zqb","email":"2506956864@qq.com","commits":1}]},"filePathRelative":"JavaSE1/jvm.md","excerpt":"\\n<p>\\"一次编译、到处运行\\" 说的是Java语言跨平台的特性， Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。 严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。</p>\\n<h2>1、解释还是编译</h2>\\n<p>我们经常听说一门语言是解释型还是编译型的语言，那么java呢？。</p>"}');export{r as comp,u as data};
